1. Как организован механизм генерации случайных чисел в библиотеке random?

берем большое число - оно (возможно) перепоняется - его с остатком делят на число MAX_RAND (например, случайное число делим на 35 - получим случайное число и диапазона 0..34)
но операция деления с остатком имеет период -> когда-нибудь число повторится

unsigned int PRNG() {
	static unsigned int seed = 1;
	seed = (4324365 * seed + 3242413);
	return seed % 32478;  // MAX_RAND = 32467
}

c++ <random>:
1) random device - дает аппртное зерно (device seed) - целое число с небольшой энтропией, которую нужно увеличить
2) random generator - увеличивает энтропию (m19937)
3) распределение - делим полученное число на другое для получения нужного разброса

2. Чем отличаются функциональные объекты от функций и лямбда-выражений?

Функтор - класс, в котором перегружен оператор ()
	- многие алгоритмы стандартной библиотеки шаблонов работают с функторами
	- сосотяние функтора можно сохраниять в памяти элемента
	- функтор запоминает что было
	- у указаеля состояния нет

лямбда-выражение - анонимный объект функтор - можно писать налету
Назначение лямбды тоже, что и функтора, т. е. передача алгоритму определенных параметров поведения.
	-лямбда позволяет определить функцию в месте её использования в отличие от функтора


3. Какими наборами возможностей обладают итераторы различных категорий?

	Input Iterator (II):
=, !=, ==, ++, * -> для чтения (istream_iterator)
	Output Iterator (OI):
=, !=, ==, ++, * -> для записи (ostream_iterator)
	Forward Iterator (FI) - однонаправленный итератор - может перемещаться по цепочке объектов в одном направлении:
II, OI, многопроходность (forward_list)
	Bidirectionnel Iterator (BI) - двунаправленный итератор - может перемещаться из начала в конец цепочки объектов, и наоборот:
FI, —, (list, set, multiset, map и multimap)
	Random Acuss Iterator - итераторы произвольного доступа:
BI, <, >, <=, >=, +/- n, i2-i1, [n] (vector)
	Вспомогательные итераторы - выполняют вспомогательные операции по отношению к основным;
	Reverse iterator - реверсивные итераторы - обходят контейнер с начала до конца;
	Insert iterator - итераторы вставки - добавляет значения к цепочке объектов
Например, front_inserter, back_inserter или inserter. front_inserter и back_inserter не могут работать с наборами (set) и картами (map), а front_inserter к тому же не умеет добавлять данные в начало векторов (vector). Зато итератор вставки inserter добавляет объекты в любой контейнер.
	Сonstant iterator - константный итератор не допускает изменения данных, на которые он ссылается; можно считать константный итератор указателем на константу. 

4. Какая классификация предлагается для алгоритмов стандартной библиотеки?

	- модифицирующий 
	- немодифициющий
	- remove - удаляет элементы контейнера
	- сортировка
	- перестановка
	- численный (только для контейнеров из чисел)
	- reverse
	- sharple


5. Почему алгоритмы стандартной библиотеки предпочтительнее собственных?
	Алгоритмы стандартной библиотеки были придуманы, написаны и доведены до совершенства умными программистами.
	Вряд ли обычный смертный вроде меня придумает что - то лучше, чтобы то быстро и безошибочно работало.


